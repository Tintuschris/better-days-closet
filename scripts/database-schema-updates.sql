-- Database Schema Updates for Product Variants Feature
-- Execute these in Supabase SQL Editor

-- 1. Create category_attributes table
CREATE TABLE IF NOT EXISTS public.category_attributes (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  category_id bigint NOT NULL,
  has_sizes boolean DEFAULT false,
  has_colors boolean DEFAULT false,
  available_sizes text[] DEFAULT '{}',
  available_colors text[] DEFAULT '{}',
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT category_attributes_pkey PRIMARY KEY (id),
  CONSTRAINT category_attributes_category_id_fkey FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,
  CONSTRAINT category_attributes_category_id_unique UNIQUE (category_id)
);

-- 2. Add variant_id column to cart table (only if it doesn't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                   WHERE table_name = 'cart' AND column_name = 'variant_id') THEN
        ALTER TABLE public.cart ADD COLUMN variant_id bigint NULL;
    END IF;
END $$;

-- Add foreign key constraint for cart.variant_id (only if it doesn't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints
                   WHERE constraint_name = 'cart_variant_id_fkey') THEN
        ALTER TABLE public.cart
        ADD CONSTRAINT cart_variant_id_fkey
        FOREIGN KEY (variant_id) REFERENCES product_variants(id) ON DELETE SET NULL;
    END IF;
END $$;

-- 3. Add variant_id column to wishlist table (only if it doesn't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                   WHERE table_name = 'wishlist' AND column_name = 'variant_id') THEN
        ALTER TABLE public.wishlist ADD COLUMN variant_id bigint NULL;
    END IF;
END $$;

-- Add foreign key constraint for wishlist.variant_id (only if it doesn't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints
                   WHERE constraint_name = 'wishlist_variant_id_fkey') THEN
        ALTER TABLE public.wishlist
        ADD CONSTRAINT wishlist_variant_id_fkey
        FOREIGN KEY (variant_id) REFERENCES product_variants(id) ON DELETE SET NULL;
    END IF;
END $$;

-- 4. Create useful indexes for performance
CREATE INDEX IF NOT EXISTS idx_product_variants_product_id ON product_variants(product_id);
CREATE INDEX IF NOT EXISTS idx_product_variants_size ON product_variants(size);
CREATE INDEX IF NOT EXISTS idx_product_variants_color ON product_variants(color);
CREATE INDEX IF NOT EXISTS idx_cart_variant_id ON cart(variant_id);
CREATE INDEX IF NOT EXISTS idx_wishlist_variant_id ON wishlist(variant_id);
CREATE INDEX IF NOT EXISTS idx_category_attributes_category_id ON category_attributes(category_id);

-- 5. Insert default category attributes for existing categories
-- This makes existing categories work with the new system
INSERT INTO public.category_attributes (category_id, has_sizes, has_colors, available_sizes, available_colors)
SELECT 
  id,
  CASE 
    WHEN LOWER(name) IN ('women', 'men', 'kids', 'shoes') THEN true
    ELSE false
  END as has_sizes,
  CASE 
    WHEN LOWER(name) IN ('women', 'men', 'kids', 'shoes') THEN true
    ELSE false
  END as has_colors,
  CASE 
    WHEN LOWER(name) IN ('women', 'men', 'kids') THEN ARRAY['XS', 'S', 'M', 'L', 'XL', 'XXL']
    WHEN LOWER(name) = 'shoes' THEN ARRAY['36', '37', '38', '39', '40', '41', '42', '43', '44', '45']
    ELSE ARRAY[]::text[]
  END as available_sizes,
  CASE 
    WHEN LOWER(name) IN ('women', 'men', 'kids', 'shoes') THEN ARRAY['Black', 'White', 'Red', 'Blue', 'Green', 'Yellow', 'Pink', 'Purple', 'Orange', 'Brown', 'Gray', 'Navy']
    ELSE ARRAY[]::text[]
  END as available_colors
FROM categories
WHERE id NOT IN (SELECT category_id FROM category_attributes)
ON CONFLICT (category_id) DO NOTHING;

-- 6. Add RLS (Row Level Security) policies if needed
-- Enable RLS on new table
ALTER TABLE public.category_attributes ENABLE ROW LEVEL SECURITY;

-- Allow read access to category_attributes for all authenticated users
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_policies
                   WHERE tablename = 'category_attributes' AND policyname = 'Allow read access to category_attributes') THEN
        CREATE POLICY "Allow read access to category_attributes" ON public.category_attributes
        FOR SELECT USING (true);
    END IF;
END $$;

-- Allow admin users to manage category_attributes (you may need to adjust this based on your admin role setup)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_policies
                   WHERE tablename = 'category_attributes' AND policyname = 'Allow admin to manage category_attributes') THEN
        CREATE POLICY "Allow admin to manage category_attributes" ON public.category_attributes
        FOR ALL USING (true);
    END IF;
END $$;

-- 7. Create a function to automatically update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for category_attributes (only if it doesn't exist)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.triggers
                   WHERE trigger_name = 'update_category_attributes_updated_at') THEN
        CREATE TRIGGER update_category_attributes_updated_at
            BEFORE UPDATE ON category_attributes
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- 8. Add some helpful comments
COMMENT ON TABLE category_attributes IS 'Stores configuration for which categories support sizes and colors';
COMMENT ON COLUMN category_attributes.has_sizes IS 'Whether this category supports size variants';
COMMENT ON COLUMN category_attributes.has_colors IS 'Whether this category supports color variants';
COMMENT ON COLUMN category_attributes.available_sizes IS 'Array of available sizes for this category';
COMMENT ON COLUMN category_attributes.available_colors IS 'Array of available colors for this category';
COMMENT ON COLUMN cart.variant_id IS 'Reference to specific product variant in cart';
COMMENT ON COLUMN wishlist.variant_id IS 'Reference to specific product variant in wishlist';

-- Email Preferences Table for Enhanced UI
CREATE TABLE IF NOT EXISTS public.email_preferences (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  order_confirmations BOOLEAN DEFAULT TRUE,
  order_updates BOOLEAN DEFAULT TRUE,
  promotions BOOLEAN DEFAULT FALSE,
  newsletter BOOLEAN DEFAULT FALSE,
  security_alerts BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)
);

-- Enable RLS on email_preferences
ALTER TABLE public.email_preferences ENABLE ROW LEVEL SECURITY;

-- Create policy for email_preferences
CREATE POLICY "Users can manage their own email preferences" ON public.email_preferences
  FOR ALL USING (auth.uid() = user_id);

-- Add indexes for better performance
CREATE INDEX IF NOT EXISTS idx_email_preferences_user_id ON public.email_preferences(user_id);

-- Add trigger to update updated_at timestamp for email_preferences
CREATE TRIGGER update_email_preferences_updated_at
    BEFORE UPDATE ON public.email_preferences
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Comments for email_preferences table
COMMENT ON TABLE public.email_preferences IS 'User email notification preferences';
COMMENT ON COLUMN public.email_preferences.order_confirmations IS 'Receive order confirmation emails';
COMMENT ON COLUMN public.email_preferences.order_updates IS 'Receive order status update emails';
COMMENT ON COLUMN public.email_preferences.promotions IS 'Receive promotional and marketing emails';
COMMENT ON COLUMN public.email_preferences.newsletter IS 'Receive newsletter and fashion tips';
COMMENT ON COLUMN public.email_preferences.security_alerts IS 'Receive security and account alerts';
